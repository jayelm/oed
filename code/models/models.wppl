var coinWeights = [0.01, 0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 0.99];

// assumes a.length == b.length
var arraysEqual = function(as,bs) {
  return all(idF, map2(function(a, b) { return a === b }, as, bs))
}

var fairSingle = cache(function(sequence) {
  Enumerate(function() {
    return flip()
  })
})

var biasSingle = cache(function(sequence) {
  Enumerate(function() {
    var p = uniformDraw(coinWeights);
    var sampled = repeat(sequence.length, function() { flip(p) })
    condition(arraysEqual(sampled, sequence))
    return flip(p);
  })
});

var markovSingle = cache(function(sequence) {
  Enumerate(function() {
    var transitionProb = uniformDraw(coinWeights);

    var generateSequence = function(n, flipsSoFar) {
      if (flipsSoFar.length == n) {
        return flipsSoFar;
      } else {
        var lastFlip = last(flipsSoFar);
        return generateSequence(n,
                                append(flipsSoFar,
                                       flip(transitionProb) ? !lastFlip : lastFlip))
      }
    }
    var firstCoin = flip();
    var sampled = generateSequence(sequence.length, [firstCoin]);
    condition(arraysEqual(sampled, sequence));
    return flip( transitionProb ) ? !last(sampled) : last(sampled);
  })
});

var groupify = function(m) {
  return function(sequence, counts) {
    var yDist = m(sequence);

    var numHeads = counts[0],
        numTails = counts[1];

    var p = Math.exp(score(yDist, true));

    return score(Binomial({n: numHeads + numTails, p: p}), numHeads)
  }
}

var fairGroup = groupify(fairSingle),
    biasGroup = groupify(biasSingle),
    markovGroup = groupify(markovSingle);
