'use strict';
var ad = require('../ad.js');
var _ = require('underscore');
var PriorityQueue = require('priorityqueuejs');
var util = require('../util');
var ScoreAggregator = require('../aggregation/ScoreAggregator');
module.exports = function (env) {
    function Enumerate(store, k, a, wpplFn, options) {
        util.throwUnlessOpts(options, 'Enumerate');
        options = util.mergeDefaults(options, { maxExecutions: Infinity });
        this.maxExecutions = options.maxExecutions;
        this.score = 0;
        this.marginal = new ScoreAggregator();
        this.numCompletedExecutions = 0;
        this.store = store;
        this.k = k;
        this.a = a;
        this.wpplFn = wpplFn;
        var strategy = strategies[options.strategy] || defaultStrategy(options.maxExecutions);
        this.queue = strategy.makeQ();
        this.coroutine = env.coroutine;
        env.coroutine = this;
    }
    Enumerate.prototype.run = function () {
        return this.wpplFn(_.clone(this.store), env.exit, this.a);
    };
    Enumerate.prototype.nextInQueue = function () {
        var nextState = this.queue.deq();
        this.score = nextState.score;
        return nextState.continuation(nextState.store, nextState.value);
    };
    Enumerate.prototype.enqueueContinuation = function (continuation, value, score, store) {
        var state = {
            continuation: continuation,
            value: value,
            score: score,
            store: _.clone(store)
        };
        this.queue.enq(state);
    };
    var getSupport = function (dist) {
        if (dist.isContinuous || !dist.support) {
            console.error(dist);
            throw 'Enumerate can only be used with distributions that have finite support.';
        }
        var supp = dist.support();
        if (ad.scalar.peq(supp.length, 0)) {
            console.error(dist);
            throw 'Enumerate encountered a distribution with empty support!';
        }
        return supp;
    };
    Enumerate.prototype.sample = function (store, k, a, dist) {
        var support = getSupport(dist);
        _.each(support, function (value) {
            this.enqueueContinuation(k, value, ad.scalar.add(this.score, dist.score(value)), store);
        }, this);
        return this.nextInQueue();
    };
    Enumerate.prototype.factor = function (s, k, a, score) {
        this.score = ad.scalar.add(this.score, score);
        if (ad.scalar.peq(this.score, ad.scalar.sub(0, Infinity))) {
            return this.exit();
        }
        return k(s);
    };
    Enumerate.prototype.sampleWithFactor = function (store, k, a, dist, scoreFn) {
        var support = getSupport(dist);
        return util.cpsForEach(function (value, i, support$2, nextK) {
            return scoreFn(store, function (store$2, extraScore) {
                var score = ad.scalar.add(ad.scalar.add(env.coroutine.score, dist.score(value)), extraScore);
                env.coroutine.enqueueContinuation(k, value, score, store$2);
                return nextK();
            }, a, value);
        }, function () {
            return env.coroutine.nextInQueue();
        }, support);
    };
    Enumerate.prototype.exit = function (s, retval) {
        this.marginal.add(retval, this.score);
        this.numCompletedExecutions = ad.scalar.add(this.numCompletedExecutions, 1);
        if (ad.scalar.gt(this.queue.size(), 0) && ad.scalar.lt(this.numCompletedExecutions, this.maxExecutions)) {
            return this.nextInQueue();
        } else {
            if (ad.scalar.peq(this.marginal.size, 0)) {
                throw 'All paths explored by Enumerate have probability zero.';
            }
            env.coroutine = this.coroutine;
            return this.k(this.store, this.marginal.toDist());
        }
    };
    Enumerate.prototype.incrementalize = env.defaultCoroutine.incrementalize;
    var strategies = {
        'likely-first': {
            makeQ: function () {
                return new PriorityQueue(function (a, b) {
                    return ad.scalar.sub(a.score, b.score);
                });
            }
        },
        'depth-first': {
            makeQ: function () {
                var q = [];
                q.size = function () {
                    return q.length;
                };
                q.enq = q.push;
                q.deq = q.pop;
                return q;
            }
        },
        'breadth-first': {
            makeQ: function () {
                var q = [];
                q.size = function () {
                    return q.length;
                };
                q.enq = q.push;
                q.deq = q.shift;
                return q;
            }
        }
    };
    function defaultStrategy(maxExecutions) {
        return strategies[_.isFinite(maxExecutions) ? 'likely-first' : 'depth-first'];
    }
    return {
        Enumerate: function (s, k, a, wpplFn, options) {
            return new Enumerate(s, k, a, wpplFn, options).run();
        }
    };
};