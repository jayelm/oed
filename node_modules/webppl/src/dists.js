'use strict';
var ad = require('./ad.js');
var numeric = require('numeric');
var _ = require('underscore');
var util = require('./util');
var assert = require('assert');
var inspect = require('util').inspect;
var LOG_PI = 1.1447298858494002;
var LOG_2PI = 1.8378770664093453;
function Distribution() {
}
Distribution.prototype = {
    toJSON: function () {
        throw 'Not implemented';
    },
    inspect: function (depth, options) {
        if (_.has(this, 'params')) {
            return [
                this.meta.name,
                '(',
                inspect(this.params),
                ')'
            ].join('');
        } else {
            var opts = options ? _.clone(options) : {};
            opts.customInspect = false;
            return inspect(this, opts);
        }
    },
    toString: function () {
        return this.inspect();
    },
    isContinuous: false,
    constructor: Distribution
};
function isDist(x) {
    return x instanceof Distribution;
}
function clone(dist) {
    return new dist.constructor(dist.params);
}
var serialize = function (dist) {
    return util.serialize(dist);
};
var deserialize = function (JSONString) {
    var obj = util.deserialize(JSONString);
    if (!obj.probs || !obj.support) {
        throw 'Cannot deserialize a non-distribution JSON object: ' + JSONString;
    }
    return new Categorical({
        ps: obj.probs,
        vs: obj.support
    });
};
function isParams(x) {
    return typeof x === 'object' && !Array.isArray(x) && !ad.isLifted(x) && x !== null;
}
var finiteSupport = {
    MAP: function () {
        var map = { score: -Infinity };
        this.support().forEach(function (val) {
            var score = this.score(val);
            if (score > map.score) {
                map = {
                    val: val,
                    score: score
                };
            }
        }, this);
        return map;
    },
    entropy: function () {
        return _.reduce(this.support(), function (memo, x) {
            var score = this.score(x);
            return memo - (score === -Infinity ? 0 : Math.exp(score) * score);
        }, 0, this);
    },
    toJSON: function () {
        var support = this.support();
        var probs = support.map(function (s) {
            return Math.exp(this.score(s));
        }, this);
        return {
            probs: probs,
            support: support
        };
    }
};
var continuousSupport = { isContinuous: true };
var methodNames = [
    'sample',
    'score',
    'support',
    'grad',
    'print',
    'driftKernel'
];
function makeDistributionType(options) {
    options = util.mergeDefaults(options, {
        parent: Distribution,
        mixins: []
    });
    [
        'name',
        'params'
    ].forEach(function (name) {
        if (!_.has(options, name)) {
            console.log(options);
            throw 'makeDistributionType: ' + name + ' is required.';
        }
    });
    if (options.score) {
        var originalScoreFn = options.score;
        options.score = function (val) {
            if (arguments.length !== 1) {
                throw 'The score method of ' + this.meta.name + ' expected 1 argument but received ' + arguments.length + '.';
            }
            return originalScoreFn.call(this, val);
        };
    }
    var parameterNames = _.pluck(options.params, 'name');
    var extraConstructorFn = options.constructor;
    var dist = function (params) {
        if (params === undefined) {
            throw 'Parameters not supplied to ' + this.meta.name + ' distribution.';
        }
        parameterNames.forEach(function (p) {
            if (!params.hasOwnProperty(p)) {
                throw 'Parameter "' + p + '" missing from ' + this.meta.name + ' distribution.';
            }
        }, this);
        this.params = params;
        if (extraConstructorFn !== undefined) {
            extraConstructorFn.call(this);
        }
    };
    dist.prototype = Object.create(options.parent.prototype);
    dist.prototype.constructor = dist;
    dist.prototype.meta = _.pick(options, 'name', 'desc', 'params');
    _.extendOwn.apply(_, [dist.prototype].concat(options.mixins));
    _.extendOwn(dist.prototype, _.pick(options, methodNames));
    [
        'sample',
        'score'
    ].forEach(function (method) {
        if (!dist.prototype[method]) {
            throw 'makeDistributionType: method "' + method + '" not defined for ' + options.name;
        }
    });
    return dist;
}
var Uniform = makeDistributionType({
    name: 'Uniform',
    desc: 'Continuous uniform distribution on [a, b]',
    params: [
        { name: 'a' },
        { name: 'b' }
    ],
    mixins: [continuousSupport],
    sample: function () {
        var u = util.random();
        return (1 - u) * ad.value(this.params.a) + u * ad.value(this.params.b);
    },
    score: function (val) {
        if (ad.scalar.lt(val, this.params.a) || ad.scalar.gt(val, this.params.b)) {
            return ad.scalar.sub(0, Infinity);
        }
        return ad.scalar.sub(0, ad.scalar.log(ad.scalar.sub(this.params.b, this.params.a)));
    },
    support: function () {
        return {
            lower: this.params.a,
            upper: this.params.b
        };
    }
});
var UniformDrift = makeDistributionType({
    name: 'UniformDrift',
    params: [
        { name: 'a' },
        { name: 'b' },
        {
            name: 'r',
            desc: 'drift kernel radius'
        }
    ],
    parent: Uniform,
    driftKernel: function (prevVal) {
        var r = this.params.r === undefined ? 0.1 : this.params.r;
        return new Uniform({
            a: Math.max(prevVal - r, this.params.a),
            b: Math.min(prevVal + r, this.params.b)
        });
    }
});
var Bernoulli = makeDistributionType({
    name: 'Bernoulli',
    desc: 'Distribution on {true,false}',
    params: [{
            name: 'p',
            desc: 'probability of true'
        }],
    mixins: [finiteSupport],
    sample: function () {
        return util.random() < ad.value(this.params.p);
    },
    score: function (val) {
        if (ad.scalar.pneq(val, true) && ad.scalar.pneq(val, false)) {
            return ad.scalar.sub(0, Infinity);
        }
        return val ? ad.scalar.log(this.params.p) : ad.scalar.log(ad.scalar.sub(1, this.params.p));
    },
    support: function () {
        return [
            true,
            false
        ];
    },
    grad: function (val) {
        return val ? [1 / this.params.p] : [-1 / this.params.p];
    }
});
var RandomInteger = makeDistributionType({
    name: 'RandomInteger',
    desc: 'Uniform distribution on {0,1,...,n-1}',
    params: [{ name: 'n' }],
    mixins: [finiteSupport],
    sample: function () {
        return Math.floor(util.random() * this.params.n);
    },
    score: function (val) {
        var inSupport = ad.scalar.peq(val, ad.scalar.floor(val)) && ad.scalar.leq(0, val) && ad.scalar.lt(val, this.params.n);
        return inSupport ? ad.scalar.sub(0, ad.scalar.log(this.params.n)) : ad.scalar.sub(0, Infinity);
    },
    support: function () {
        return _.range(this.params.n);
    }
});
function gaussianSample(mu, sigma) {
    var u, v, x, y, q;
    do {
        u = 1 - util.random();
        v = 1.7156 * (util.random() - 0.5);
        x = u - 0.449871;
        y = Math.abs(v) + 0.386595;
        q = x * x + y * (0.196 * y - 0.25472 * x);
    } while (q >= 0.27597 && (q > 0.27846 || v * v > -4 * u * u * Math.log(u)));
    return mu + sigma * v / u;
}
function gaussianScore(mu, sigma, x) {
    return ad.scalar.mul(ad.scalar.sub(0, 0.5), ad.scalar.add(ad.scalar.add(LOG_2PI, ad.scalar.mul(2, ad.scalar.log(sigma))), ad.scalar.div(ad.scalar.mul(ad.scalar.sub(x, mu), ad.scalar.sub(x, mu)), ad.scalar.mul(sigma, sigma))));
}
var Gaussian = makeDistributionType({
    name: 'Gaussian',
    params: [
        {
            name: 'mu',
            desc: 'mean'
        },
        {
            name: 'sigma',
            desc: 'standard deviation'
        }
    ],
    mixins: [continuousSupport],
    sample: function () {
        return gaussianSample(ad.value(this.params.mu), ad.value(this.params.sigma));
    },
    score: function (x) {
        return gaussianScore(this.params.mu, this.params.sigma, x);
    }
});
var GaussianDrift = makeDistributionType({
    name: 'GaussianDrift',
    params: [
        {
            name: 'mu',
            desc: 'mean'
        },
        {
            name: 'sigma',
            desc: 'standard deviation'
        }
    ],
    parent: Gaussian,
    driftKernel: function (curVal) {
        return new Gaussian({
            mu: curVal,
            sigma: this.params.sigma * 0.7
        });
    }
});
function multivariateGaussianSample(mu, cov) {
    var xs = mu.map(function () {
        return gaussianSample(0, 1);
    });
    var svd = numeric.svd(cov);
    var scaledV = numeric.transpose(svd.V).map(function (x) {
        return numeric.mul(numeric.sqrt(svd.S), x);
    });
    xs = numeric.dot(xs, numeric.transpose(scaledV));
    return numeric.add(xs, mu);
}
function multivariateGaussianScore(mu, cov, x) {
    var n = mu.length;
    var coeffs = n * LOG_2PI + Math.log(numeric.det(cov));
    var xSubMu = numeric.sub(x, mu);
    var exponents = numeric.dot(numeric.dot(xSubMu, numeric.inv(cov)), xSubMu);
    return -0.5 * (coeffs + exponents);
}
var MultivariateGaussian = makeDistributionType({
    name: 'MultivariateGaussian',
    params: [
        {
            name: 'mu',
            desc: 'mean vector'
        },
        {
            name: 'cov',
            desc: 'covariance matrix'
        }
    ],
    sample: function () {
        return multivariateGaussianSample(this.params.mu, this.params.cov);
    },
    score: function (val) {
        return multivariateGaussianScore(this.params.mu, this.params.cov, val);
    }
});
var Cauchy = makeDistributionType({
    name: 'Cauchy',
    params: [
        { name: 'location' },
        { name: 'scale' }
    ],
    mixins: [continuousSupport],
    sample: function () {
        var u = util.random();
        return ad.value(this.params.location) + ad.value(this.params.scale) * Math.tan(180 * (u - 0.5));
    },
    score: function (x) {
        var scale = this.params.scale;
        var location = this.params.location;
        return ad.scalar.sub(ad.scalar.sub(ad.scalar.sub(0, LOG_PI), ad.scalar.log(scale)), ad.scalar.log(ad.scalar.add(1, ad.scalar.pow(ad.scalar.div(ad.scalar.sub(x, location), scale), 2))));
    }
});
function sum(xs) {
    return xs.reduce(function (a, b) {
        return ad.scalar.add(a, b);
    }, 0);
}
var Discrete = makeDistributionType({
    name: 'Discrete',
    desc: 'Distribution on {0,1,...,ps.length-1} with P(i) proportional to ps[i]',
    params: [{
            name: 'ps',
            desc: 'array of probabilities'
        }],
    mixins: [finiteSupport],
    sample: function () {
        return discreteSample(this.params.ps.map(ad.value));
    },
    score: function (val) {
        var n = this.params.ps.length;
        var inSupport = ad.scalar.peq(val, ad.scalar.floor(val)) && ad.scalar.leq(0, val) && ad.scalar.lt(val, n);
        return inSupport ? ad.scalar.log(ad.scalar.div(this.params.ps[val], sum(this.params.ps))) : ad.scalar.sub(0, Infinity);
    },
    support: function (params) {
        return _.range(this.params.ps.length);
    }
});
var gammaCof = [
    76.18009172947146,
    -86.50532032941678,
    24.01409824083091,
    -1.231739572450155,
    0.001208650973866179,
    -0.000005395239384953
];
function logGamma(xx) {
    var x = ad.scalar.sub(xx, 1);
    var tmp = ad.scalar.add(x, 5.5);
    tmp = ad.scalar.sub(tmp, ad.scalar.mul(ad.scalar.add(x, 0.5), ad.scalar.log(tmp)));
    var ser = 1.000000000190015;
    for (var j = 0; ad.scalar.leq(j, 5); j = ad.scalar.add(j, 1)) {
        x = ad.scalar.add(x, 1);
        ser = ad.scalar.add(ser, ad.scalar.div(gammaCof[j], x));
    }
    return ad.scalar.add(ad.scalar.sub(0, tmp), ad.scalar.log(ad.scalar.mul(2.5066282746310007, ser)));
}
function gammaSample(shape, scale) {
    if (shape < 1) {
        var r;
        r = gammaSample(1 + shape, scale) * Math.pow(util.random(), 1 / shape);
        if (r === 0) {
            util.warn('gamma sample underflow, rounded to nearest representable support value');
            return Number.MIN_VALUE;
        }
        return r;
    }
    var x, v, u;
    var d = shape - 1 / 3;
    var c = 1 / Math.sqrt(9 * d);
    while (true) {
        do {
            x = gaussianSample(0, 1);
            v = 1 + c * x;
        } while (v <= 0);
        v = v * v * v;
        u = util.random();
        if (u < 1 - 0.331 * x * x * x * x || Math.log(u) < 0.5 * x * x + d * (1 - v + Math.log(v))) {
            return scale * d * v;
        }
    }
}
function expGammaSample(shape, scale) {
    if (shape < 1) {
        var r;
        r = gammaSample(1 + shape, scale) + Math.log(util.random()) / shape;
        if (r === -Infinity) {
            util.warn('log gamma sample underflow, rounded to nearest representable support value');
            return -Number.MAX_VALUE;
        }
        return r;
    }
    var x, v, u, log_v;
    var d = shape - 1 / 3;
    var c = 1 / Math.sqrt(9 * d);
    while (true) {
        do {
            x = gaussianSample(0, 1);
            v = 1 + c * x;
        } while (v <= 0);
        log_v = 3 * Math.log(v);
        v = v * v * v;
        u = util.random();
        if (u < 1 - 0.331 * x * x * x * x || Math.log(u) < 0.5 * x * x + d * (1 - v + Math.log(v))) {
            return Math.log(scale) + Math.log(d) + log_v;
        }
    }
}
function expGammaScore(shape, scale, val) {
    var x = val;
    return ad.scalar.sub(ad.scalar.sub(ad.scalar.sub(ad.scalar.mul(ad.scalar.sub(shape, 1), x), ad.scalar.div(ad.scalar.exp(x), scale)), logGamma(shape)), ad.scalar.mul(shape, ad.scalar.log(scale)));
}
var Gamma = makeDistributionType({
    name: 'Gamma',
    params: [
        { name: 'shape' },
        { name: 'scale' }
    ],
    mixins: [continuousSupport],
    sample: function () {
        return gammaSample(ad.value(this.params.shape), ad.value(this.params.scale));
    },
    score: function (x) {
        var shape = this.params.shape;
        var scale = this.params.scale;
        return ad.scalar.sub(ad.scalar.sub(ad.scalar.sub(ad.scalar.mul(ad.scalar.sub(shape, 1), ad.scalar.log(x)), ad.scalar.div(x, scale)), logGamma(shape)), ad.scalar.mul(shape, ad.scalar.log(scale)));
    },
    support: function () {
        return {
            lower: 0,
            upper: Infinity
        };
    }
});
var Exponential = makeDistributionType({
    name: 'Exponential',
    params: [{
            name: 'a',
            desc: 'rate'
        }],
    mixins: [continuousSupport],
    sample: function () {
        var u = util.random();
        return Math.log(u) / (-1 * ad.value(this.params.a));
    },
    score: function (val) {
        return ad.scalar.sub(ad.scalar.log(this.params.a), ad.scalar.mul(this.params.a, val));
    },
    support: function () {
        return {
            lower: 0,
            upper: Infinity
        };
    }
});
function logBeta(a, b) {
    return ad.scalar.sub(ad.scalar.add(logGamma(a), logGamma(b)), logGamma(ad.scalar.add(a, b)));
}
var Beta = makeDistributionType({
    name: 'Beta',
    params: [
        { name: 'a' },
        { name: 'b' }
    ],
    mixins: [continuousSupport],
    sample: function () {
        return betaSample(ad.value(this.params.a), ad.value(this.params.b));
    },
    score: function (x) {
        var a = this.params.a;
        var b = this.params.b;
        return ad.scalar.gt(x, 0) && ad.scalar.lt(x, 1) ? ad.scalar.sub(ad.scalar.add(ad.scalar.mul(ad.scalar.sub(a, 1), ad.scalar.log(x)), ad.scalar.mul(ad.scalar.sub(b, 1), ad.scalar.log(ad.scalar.sub(1, x)))), logBeta(a, b)) : ad.scalar.sub(0, Infinity);
    },
    support: function () {
        return {
            lower: 0,
            upper: 1
        };
    }
});
function betaSample(a, b) {
    var x = gammaSample(a, 1);
    return x / (x + gammaSample(b, 1));
}
function binomialG(x) {
    if (ad.scalar.peq(x, 0)) {
        return 1;
    }
    if (ad.scalar.peq(x, 1)) {
        return 0;
    }
    var d = ad.scalar.sub(1, x);
    return ad.scalar.div(ad.scalar.add(ad.scalar.sub(1, ad.scalar.mul(x, x)), ad.scalar.mul(ad.scalar.mul(2, x), ad.scalar.log(x))), ad.scalar.mul(d, d));
}
function binomialSample(p, n) {
    var k = 0;
    var N = 10;
    var a, b;
    while (n > N) {
        a = 1 + n / 2;
        b = 1 + n - a;
        var x = betaSample(a, b);
        if (x >= p) {
            n = a - 1;
            p /= x;
        } else {
            k += a;
            n = b - 1;
            p = (p - x) / (1 - x);
        }
    }
    var u;
    for (var i = 0; i < n; i++) {
        u = util.random();
        if (u < p) {
            k++;
        }
    }
    return k || 0;
}
var Binomial = makeDistributionType({
    name: 'Binomial',
    desc: 'Distribution over the number of successes for n independent ``Bernoulli({p: p})`` trials',
    params: [
        {
            name: 'p',
            desc: 'success probability'
        },
        {
            name: 'n',
            desc: 'number of trials'
        }
    ],
    mixins: [finiteSupport],
    sample: function () {
        return binomialSample(ad.value(this.params.p), this.params.n);
    },
    score: function (val) {
        var p = this.params.p;
        var n = this.params.n;
        if (ad.scalar.gt(n, 20) && ad.scalar.gt(ad.scalar.mul(n, p), 5) && ad.scalar.gt(ad.scalar.mul(n, ad.scalar.sub(1, p)), 5)) {
            var s = val;
            var inv2 = ad.scalar.div(1, 2);
            var inv3 = ad.scalar.div(1, 3);
            var inv6 = ad.scalar.div(1, 6);
            if (ad.scalar.geq(s, n)) {
                return ad.scalar.sub(0, Infinity);
            }
            var q = ad.scalar.sub(1, p);
            var S = ad.scalar.add(s, inv2);
            var T = ad.scalar.sub(ad.scalar.sub(n, s), inv2);
            var d1 = ad.scalar.sub(ad.scalar.add(s, inv6), ad.scalar.mul(ad.scalar.add(n, inv3), p));
            var d2 = ad.scalar.add(ad.scalar.sub(ad.scalar.div(q, ad.scalar.add(s, inv2)), ad.scalar.div(p, ad.scalar.add(T, inv2))), ad.scalar.div(ad.scalar.sub(q, inv2), ad.scalar.add(n, 1)));
            d2 = ad.scalar.add(d1, ad.scalar.mul(0.02, d2));
            var num = ad.scalar.add(ad.scalar.add(1, ad.scalar.mul(q, binomialG(ad.scalar.div(S, ad.scalar.mul(n, p))))), ad.scalar.mul(p, binomialG(ad.scalar.div(T, ad.scalar.mul(n, q)))));
            var den = ad.scalar.mul(ad.scalar.mul(ad.scalar.add(n, inv6), p), q);
            var z = ad.scalar.div(num, den);
            var invsd = ad.scalar.sqrt(z);
            z = ad.scalar.mul(d2, invsd);
            return ad.scalar.add(gaussianScore(0, 1, z), ad.scalar.log(invsd));
        } else {
            return ad.scalar.add(ad.scalar.add(ad.scalar.sub(ad.scalar.sub(lnfact(n), lnfact(ad.scalar.sub(n, val))), lnfact(val)), ad.scalar.mul(val, ad.scalar.log(p))), ad.scalar.mul(ad.scalar.sub(n, val), ad.scalar.log(ad.scalar.sub(1, p))));
        }
    },
    support: function () {
        return _.range(this.params.n).concat(this.params.n);
    }
});
function zeros(n) {
    var a = new Array(n);
    for (var i = 0; i < n; i++) {
        a[i] = 0;
    }
    return a;
}
function multinomialSample(theta, n) {
    var a = zeros(theta.length);
    for (var i = 0; i < n; i++) {
        a[discreteSample(theta)]++;
    }
    return a;
}
var Multinomial = makeDistributionType({
    name: 'Multinomial',
    desc: 'Distribution over counts for n independent ``Discrete({ps: ps})`` trials',
    params: [
        {
            name: 'ps',
            desc: 'probabilities'
        },
        {
            name: 'n',
            desc: 'number of trials'
        }
    ],
    mixins: [finiteSupport],
    sample: function () {
        return multinomialSample(this.params.ps.map(ad.value), this.params.n);
    },
    score: function (val) {
        if (ad.scalar.pneq(sum(val), this.params.n)) {
            return ad.scalar.sub(0, Infinity);
        }
        var x = [];
        var y = [];
        for (var i = 0; ad.scalar.lt(i, this.params.ps.length); i = ad.scalar.add(i, 1)) {
            x[i] = lnfact(val[i]);
            y[i] = ad.scalar.mul(val[i], ad.scalar.log(this.params.ps[i]));
        }
        return ad.scalar.add(ad.scalar.sub(lnfact(this.params.n), sum(x)), sum(y));
    },
    support: function () {
        var combinations = allDiscreteCombinations(this.params.n, this.params.ps, [], 0);
        var toHist = function (l) {
            return buildHistogramFromCombinations(l, this.params.ps);
        }.bind(this);
        var hists = combinations.map(toHist);
        return hists;
    }
});
function allDiscreteCombinations(k, states, got, pos) {
    var support = [];
    if (got.length == k) {
        return [_.clone(got)];
    }
    for (var i = pos; i < states.length; i++) {
        got.push(i);
        support = support.concat(allDiscreteCombinations(k, states, got, i));
        got.pop();
    }
    return support;
}
function buildHistogramFromCombinations(samples, states) {
    var stateIndices = _.range(states.length);
    var zeroHist = _.chain(stateIndices).map(function (i) {
        return [
            i,
            0
        ];
    }).object().value();
    var hist = _.defaults(_.countBy(samples), zeroHist);
    var array = _.sortBy(hist, function (val, key) {
        return key;
    });
    return array;
}
function fact(x) {
    var t = 1;
    while (ad.scalar.gt(x, 1)) {
        t = ad.scalar.mul(t, x);
        x = ad.scalar.sub(x, 1);
    }
    return t;
}
function lnfact(x) {
    if (ad.scalar.lt(x, 1)) {
        x = 1;
    }
    if (ad.scalar.lt(x, 12)) {
        return ad.scalar.log(fact(ad.scalar.round(x)));
    }
    var invx = ad.scalar.div(1, x);
    var invx2 = ad.scalar.mul(invx, invx);
    var invx3 = ad.scalar.mul(invx2, invx);
    var invx5 = ad.scalar.mul(invx3, invx2);
    var invx7 = ad.scalar.mul(invx5, invx2);
    var sum = ad.scalar.sub(ad.scalar.mul(ad.scalar.add(x, 0.5), ad.scalar.log(x)), x);
    sum = ad.scalar.add(sum, ad.scalar.div(ad.scalar.log(ad.scalar.mul(2, ad.scalar.PI)), 2));
    sum = ad.scalar.add(sum, ad.scalar.sub(ad.scalar.div(invx, 12), ad.scalar.div(invx3, 360)));
    sum = ad.scalar.add(sum, ad.scalar.sub(ad.scalar.div(invx5, 1260), ad.scalar.div(invx7, 1680)));
    return sum;
}
var Poisson = makeDistributionType({
    name: 'Poisson',
    params: [{ name: 'mu' }],
    sample: function () {
        var k = 0;
        var mu = ad.value(this.params.mu);
        while (mu > 10) {
            var m = 7 / 8 * mu;
            var x = gammaSample(m, 1);
            if (x > mu) {
                return k + binomialSample(mu / x, m - 1) || 0;
            } else {
                mu -= x;
                k += m;
            }
        }
        var emu = Math.exp(-mu);
        var p = 1;
        do {
            p *= util.random();
            k++;
        } while (p > emu);
        return k - 1 || 0;
    },
    score: function (val) {
        return ad.scalar.sub(ad.scalar.sub(ad.scalar.mul(val, ad.scalar.log(this.params.mu)), this.params.mu), lnfact(val));
    }
});
function dirichletSample(alpha) {
    var n = alpha.length;
    var ssum = 0;
    var theta = [];
    var t;
    for (var i = 0; i < n; i++) {
        t = gammaSample(alpha[i], 1);
        theta[i] = t;
        ssum = ssum + t;
    }
    for (var j = 0; j < n; j++) {
        theta[j] /= ssum;
        if (theta[j] === 0) {
            theta[j] = Number.EPSILON;
        }
        if (theta[j] === 1) {
            theta[j] = 1 - Number.EPSILON;
        }
    }
    return theta;
}
function dirichletScore(alpha, val) {
    var theta = val;
    var asum = 0;
    for (var i = 0; i < alpha.length; i++) {
        asum += alpha[i];
    }
    var logp = logGamma(asum);
    for (var j = 0; j < alpha.length; j++) {
        logp += (alpha[j] - 1) * Math.log(theta[j]);
        logp -= logGamma(alpha[j]);
    }
    return logp;
}
var Dirichlet = makeDistributionType({
    name: 'Dirichlet',
    params: [{
            name: 'alpha',
            desc: 'array of concentration parameters'
        }],
    sample: function () {
        return dirichletSample(this.params.alpha);
    },
    score: function (val) {
        return dirichletScore(this.params.alpha, val);
    }
});
var DirichletDrift = makeDistributionType({
    name: 'DirichletDrift',
    parent: Dirichlet,
    params: [{
            name: 'alpha',
            desc: 'array of concentration parameters'
        }],
    driftKernel: function (prevVal) {
        var concentration = 10;
        var alpha = prevVal.map(function (x) {
            return concentration * x;
        });
        return new Dirichlet({ alpha: alpha });
    }
});
function discreteSample(theta) {
    var thetaSum = util.sum(theta);
    var x = util.random() * thetaSum;
    var k = theta.length;
    var probAccum = 0;
    for (var i = 0; i < k; i++) {
        probAccum += theta[i];
        if (x < probAccum) {
            return i;
        }
    }
    return k - 1;
}
var Marginal = makeDistributionType({
    name: 'Marginal',
    params: [{ name: 'dist' }],
    mixins: [finiteSupport],
    constructor: function () {
        var norm = _.reduce(this.params.dist, function (acc, obj) {
            return ad.scalar.add(acc, obj.prob);
        }, 0);
        assert.ok(ad.scalar.lt(ad.scalar.abs(ad.scalar.sub(1, norm)), 1e-8), 'Expected marginal distribution to be normalized.');
        this.supp = _.map(this.params.dist, function (obj) {
            return obj.val;
        });
    },
    sample: function () {
        var x = util.random();
        var dist = this.params.dist;
        var probAccum = 0;
        for (var i in dist) {
            if (dist.hasOwnProperty(i)) {
                probAccum = ad.scalar.add(probAccum, dist[i].prob);
                if (ad.scalar.lt(x, probAccum)) {
                    return dist[i].val;
                }
            }
        }
        return this.params.dist[i].val;
    },
    score: function (val) {
        var obj = this.params.dist[util.serialize(val)];
        return obj ? ad.scalar.log(obj.prob) : ad.scalar.sub(0, Infinity);
    },
    support: function () {
        return this.supp;
    },
    print: function () {
        return _.map(this.params.dist, function (obj, val) {
            return [
                val,
                obj.prob
            ];
        }).sort(function (a, b) {
            return b[1] - a[1];
        }).map(function (pair) {
            return '    ' + pair[0] + ' : ' + pair[1];
        }).join('\n');
    }
});
var Categorical = makeDistributionType({
    name: 'Categorical',
    desc: 'Distribution over elements of vs with P(vs[i]) = ps[i]',
    params: [
        {
            name: 'ps',
            desc: 'array of probabilities'
        },
        {
            name: 'vs',
            desc: 'support'
        }
    ],
    mixins: [finiteSupport],
    constructor: function () {
        this.dist = _.object(this.params.vs.map(function (v, i) {
            return [
                util.serialize(v),
                {
                    val: v,
                    prob: this.params.ps[i]
                }
            ];
        }, this));
    },
    sample: function () {
        var vs = this.params.vs.map(ad.value);
        var ps = this.params.ps.map(ad.value);
        return vs[discreteSample(ps)];
    },
    score: function (val) {
        var obj = this.dist[util.serialize(val)];
        return obj ? ad.scalar.log(obj.prob) : ad.scalar.sub(0, Infinity);
    },
    support: function () {
        return this.params.vs;
    }
});
function withImportanceDist(dist, importanceDist) {
    var newDist = clone(dist);
    newDist.importanceDist = importanceDist;
    return newDist;
}
module.exports = {
    Uniform: Uniform,
    UniformDrift: UniformDrift,
    Bernoulli: Bernoulli,
    RandomInteger: RandomInteger,
    Gaussian: Gaussian,
    GaussianDrift: GaussianDrift,
    MultivariateGaussian: MultivariateGaussian,
    Cauchy: Cauchy,
    Discrete: Discrete,
    Gamma: Gamma,
    Exponential: Exponential,
    Beta: Beta,
    Binomial: Binomial,
    Multinomial: Multinomial,
    Poisson: Poisson,
    Dirichlet: Dirichlet,
    DirichletDrift: DirichletDrift,
    Marginal: Marginal,
    Categorical: Categorical,
    discreteSample: discreteSample,
    gaussianSample: gaussianSample,
    gammaSample: gammaSample,
    dirichletSample: dirichletSample,
    serialize: serialize,
    deserialize: deserialize,
    withImportanceDist: withImportanceDist,
    isDist: isDist,
    isParams: isParams
};